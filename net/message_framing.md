### TCP粘包的由来

可能对于很多人来说，粘包是一个比较低级甚至是不值得讨论的问题，就我而言，这个问题所带来的有趣的点还是很多的，这种自底向上的学习过程往往有更深入的理解。

#### 简单说说粘包

TCP/IP 协议簇建立了互联网中通信协议的概念模型，该协议簇中的两个主要协议就是 TCP 和 IP 协议。
TCP/ IP 协议簇中的 TCP 协议能够保证数据段（Segment）的可靠性和顺序，有了可靠的传输层协议之后，应用层协议就可以直接使用 TCP 协议传输数据，不在需要关心数据段的丢失和重复问题。

IP协议解决了数据包的路由和传输，上层的TCP协议不需要再关注路由和寻址，相对应的，TCP协议解决的是传输的可靠性和顺序问题，上层不需要关心数据能否传输到目标。当应用层协议使用TCP协议进行数据传输的时候，TCP协议可能会将数据分成多个包依次发送，那么数据接收方就有可能收到由多个应用数据包组成的数据段，这个时候就需要对收到的数据进行拆分。当然，粘包并不是因为TCP协议造成的，之所以会出现是因为应用层协议设计者对TCP协议的误解。

简单来说：

- TCP协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据；
- 应用层协议没有定义消息的边界导致数据的接收方无法拼接数据；

#### TCP：面向字节流

TCP 协议是面向连接的、可靠的、基于字节流的传输层通信协议，应用层交给TCP协议的数据并不会以消息为单位向目的主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标的主机。

其中，Nagle 算法是一种通过减少数据包的方式提高 TCP 传输性能的算法。因为网络的带宽有限，它不会将小的数据块直接发送到目的主机，而是会在本地缓冲区中等待更多待发送的数据，这种批量发送数据的策略虽然会影响实时性和网络延迟，但是能够降低网络拥堵的可能性并减少额外开销。

当应用层协议通过 TCP 协议传输数据时，实际上待发送的数据先被写入了TCP协议的缓冲区，如果用户开启了 Nagle 算法，那么TCP协议可能不会立刻发送写入的数据，它会等待缓冲区中数据超过最大数据段（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。（现在该算法在Linux是默认关闭的，毕竟今天的网络带宽资源已经不比之前了）。

Nagle 算法确实能够在数据包较小时提高网络带宽的利用率并减少TCP和IP协议头带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被合并或者拆分发送，当接收方从TCP协议栈中读取数据时会发现不相关的数据出现在了同一个数据段中，应用层协议可能没有办法对它们进行拆分和重组。


除了 Nagle 算法之外，TCP协议栈中还有另一个用于延迟发送数据的选项 TCP_CORK，如果我们开启该选项，那么当发送的数据小于 MSS 时，TCP 协议就会延迟200ms发送该数据或者等待缓冲区中的数据超过 MSS。

无论是 TCP_NODELAY 还是 TCP_CORK，它们都会通过延迟发送数据来提高带宽的利用率，它们会对应用层协议写入的数据进行拆分和重组，而这些机制和配置能够出现的最重要原因是 — TCP协议是基于字节流的协议，其本身没有数据包的概念，不会按照数据包发送数据。


#### TCP：消息边界

既然 TCP 协议是基于字节流的，这其实就意味着应用层协议要自己划分消息的边界。如果我们能在应用层协议中定义消息的边界，那么无论TCP协议如何对应用层协议的数据包进程拆分和重组，接收方都能根据协议的规则恢复对应的消息。在应用层协议中，最常见的两种解决方案就是基于长度或者基于终结符（Delimiter）。

- 基于长度的实现有两种方式，一种是使用固定长度，所有的应用层消息都使用统一的大小，另一种方式是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，这样接收方才可以从字节流中分离出不同的消息，HTTP协议的消息边界就是基于长度实现的，比如Content-Length头；不过 HTTP 协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当 HTTP 使用块传输（Chunked Transfer）机制时，HTTP 头中就不再包含Content-Length了，它会使用负载大小为0的 HTTP消息作为终结符表示消息的边界。

- 当然除了这两种方式之外，我们可以基于特定的规则实现消息的边界，例如：使用 TCP 协议发送 JSON 数据，接收方可以根据接收到的数据是否能够被解析成合法的 JSON 判断消息是否终结。


#### 最后叨叨几句

TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧，Message Framing，这也是我这个文件命名的由来啦




