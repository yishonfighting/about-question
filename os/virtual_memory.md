# 关于虚拟内存

说到操作系统，最常被提及的，总会是CPU、内存、虚拟内存...对于操作系统而言，CPU和主内存都是属于稀缺的资源，以至于所有运行在os中的进程都需要共享系统中的CPU和内存资源。os会使用CPU调度器来分配CPU的占用时间，并且引入虚拟内存来对物理内存进行管理。

那么虚拟内存是什么呢？

看过到一个比较形象对说明：__虚拟内存是os物理内存和进程之间对中间层__，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。

但是操作系统被设计之初，是没有使用到虚拟内存的，系统中的进程会直接访问主内存中的物理地址，访问内存中的内容。

这么设计看似简单直接，但是带来的问题也是致命的：

1. 因为进程地址空间没有隔离，不同程序可以互相访问到对方的物理内存，可以是有意也可以是无意；
2. 内存的使用效率低。在多个应用程序运行的时候，因为运行另外一个程序需要加载对应大小的内存才能运行，势必造成频繁的数据拷贝；
3. 程序运行的时候地址不确定，因为内存的分配是随机的

现代的操作系统都引入了虚拟内存，进程持有的虚拟地址会经过内存管理单元的转换变成物理地址，然后再通过物理地址（MMU）访问内存。
前面说到了，主存储是相对稀缺的资源，它在随机访问上提供了极快的处理时间，随机读取数据的时候会是磁盘的10W倍，不过呢，对于顺序读取优势就没有那么明显了，只领先了一个数量级。这些都得益于内存的分页设计。

os以页为单位管理内存，当进程发现需要访问的数据不在内存中的时候，会将数据以页的方式加载到内存中，也就是通过内存管理单元（MMU）来完成的，虚拟内存在中间起到了几个很关键的作用：

1. 虚拟内存可以为进程提供独立的内存空间，简化程序的连接、加载过程并通过动态库共享内存；
2. 虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度；
3. 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统安全性

这三个点其实也是对应上面提出初代os的问题的解决。

我们可以把虚拟内存看做磁盘上的一片空间，当这片空间的一部分被频繁访问的时候，这部分数据会以页为单位被缓存到主存中，加速CPU访问的效率。
很多时候不单单是生活，虚拟内存利用空间较大的磁盘存储作为"内存"，并使用主存缓存进行加速，这是设计的精妙，上层应用程序认为os的内存很大而且使用起来很快，但是实际上是，拥有很大空间的磁盘并不快，处理很快的内存也并不大。各类算法实现也都展现出如此，大部分时候，空间跟时间效率都不能两者并兼

继续上面的内容，虚拟内存中的虚拟页（virtual page）会有三种状态：

1. unallocated , 未分配的内存页是没有被进程申请使用的，即空闲的虚拟内存，不会占用虚拟内存磁盘的任何空间；
2. uncached ， 表示加载到磁盘中的内存页
3. cached ， 表示已经加载到主存中的内存页

当用户程序访问未被缓存的虚拟页时，硬件就会触发缺页中断（page fault），在部分情况下，被访问的页面已经加载到了物理内存中，但是用户程序的页表（page table）并不存在该对应关系，这时我们只需要在页表中建立虚拟内存到物理内存的关系；在其他情况下，OS需要将磁盘上未被缓存的虚拟页加载到物理内存中。

因为主内存的空间是有限的，当主内存中不包含可以使用的空间时，OS会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在OS中叫做页面替换（page replacement).缺页中断和页面替换技术部是OS调页算法（paging）的一部分，该算法的目的就是充分利用内存资源作为磁盘的缓存以提高程序的运行效率。
