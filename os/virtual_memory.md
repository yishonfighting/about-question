# 关于虚拟内存

说到操作系统，最常被提及的，总会是CPU、内存、虚拟内存...对于操作系统而言，CPU和主内存都是属于稀缺的资源，以至于所有运行在os中的进程都需要共享系统中的CPU和内存资源。os会使用CPU调度器来分配CPU的占用时间，并且引入虚拟内存来对物理内存进行管理。

那么虚拟内存是什么呢？

### 什么是虚拟内存

看过到一个比较形象对说明：__虚拟内存是os物理内存和进程之间对中间层__，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。

但是操作系统被设计之初，是没有使用到虚拟内存的，系统中的进程会直接访问主内存中的物理地址，访问内存中的内容。

这么设计看似简单直接，但是带来的问题也是致命的：

1. 因为进程地址空间没有隔离，不同程序可以互相访问到对方的物理内存，可以是有意也可以是无意；
2. 内存的使用效率低。在多个应用程序运行的时候，因为运行另外一个程序需要加载对应大小的内存才能运行，势必造成频繁的数据拷贝；
3. 程序运行的时候地址不确定，因为内存的分配是随机的

现代的操作系统都引入了虚拟内存，进程持有的虚拟地址会经过内存管理单元的转换变成物理地址，然后再通过物理地址（MMU）访问内存。
前面说到了，主存储是相对稀缺的资源，它在随机访问上提供了极快的处理时间，随机读取数据的时候会是磁盘的10W倍，不过呢，对于顺序读取优势就没有那么明显了，只领先了一个数量级。这些都得益于内存的分页设计。

os以页为单位管理内存，当进程发现需要访问的数据不在内存中的时候，会将数据以页的方式加载到内存中，也就是通过内存管理单元（MMU）来完成的，虚拟内存在中间起到了几个很关键的作用：

1. 虚拟内存可以为进程提供独立的内存空间，简化程序的连接、加载过程并通过动态库共享内存；
2. 虚拟内存可以利用内存起到缓存的作用，提高进程访问磁盘的速度；
3. 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统安全性

这三个点其实也是对应上面提出初代os的问题的解决。

我们可以把虚拟内存看做磁盘上的一片空间，当这片空间的一部分被频繁访问的时候，这部分数据会以页为单位被缓存到主存中，加速CPU访问的效率。
很多时候不单单是生活，虚拟内存利用空间较大的磁盘存储作为"内存"，并使用主存缓存进行加速，这是设计的精妙，上层应用程序认为os的内存很大而且使用起来很快，但是实际上是，拥有很大空间的磁盘并不快，处理很快的内存也并不大。各类算法实现也都展现出如此，大部分时候，空间跟时间效率都不能两者并兼

继续上面的内容，虚拟内存中的虚拟页（virtual page）会有三种状态：

1. unallocated , 未分配的内存页是没有被进程申请使用的，即空闲的虚拟内存，不会占用虚拟内存磁盘的任何空间；
2. uncached ， 表示加载到磁盘中的内存页
3. cached ， 表示已经加载到主存中的内存页

当用户程序访问未被缓存的虚拟页时，硬件就会触发缺页中断（page fault），在部分情况下，被访问的页面已经加载到了物理内存中，但是用户程序的页表（page table）并不存在该对应关系，这时我们只需要在页表中建立虚拟内存到物理内存的关系；在其他情况下，OS需要将磁盘上未被缓存的虚拟页加载到物理内存中。

因为主内存的空间是有限的，当主内存中不包含可以使用的空间时，OS会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在OS中叫做页面替换（page replacement).缺页中断和页面替换技术部是OS调页算法（paging）的一部分，该算法的目的就是充分利用内存资源作为磁盘的缓存以提高程序的运行效率。


前面说了那么长的篇幅，相信都会存在这么一个问题：对于虚拟内存，os是怎么去进行管理的呢？

### 内存管理

虚拟内存可以作为正在运行的进程提供独立的内存空间，制造一种每个进程的内存都是独立的假象，比如在64的操作系统上，每个进程都会拥有256TiB的内存空间，内核空间和用户空间分别占128TiB.
部分操作系统使用57位虚拟地址以提供128PiB的寻址空间。因为每个进程的虚拟内存是完全独立的，所以它们都可以完整的使用0x0000000000000000到0x00007FFFFFFFFFFF的全部内存。

虚拟内存空间只是操作系统中的逻辑结构，就像我们上面说的，应用程序最终还是需要访问物理内存或者磁盘上的内容。因为OS加了一个虚拟内存的中间层，所以我们也需要为进程实现这个地址的"翻译器"。
实现从虚拟地址到物理地址的转换，页表是虚拟内存系统中的重要数据结构，每个进程的页表中都存储了从虚拟内存到物理内存页的映射关系（Linux在4。11中引入了五层的页表结构）。正是因为多层的页表结构可以用来
转换虚拟地址，所以多个进程可以通过虚拟内存来共享物理内存，Redis的写时复制就是利用了这个特性，当我们在Linux中调用fork创建子进程的时候，实际上只复制了父进程的页表。父子进程会通过不同的页表指向相同的物理内存。

虚拟内存不仅可以在fork时用于共享进程的物理内存，提供写时复制的机制，还能共享一些常见的动态库减少物理内存的占用，所有的进程都可能调用相同的OS内核代码，而C语言程序也会调用相同的标准库。

除了能共享内存之外，独立的虚拟内存空间也会简化内存的分配过程，当用户程序向操作系统申请堆内存的时候，操作系统可以分配几个连续的虚拟页，但是这些虚拟页可以对应到物理内存中不连续的页中。
