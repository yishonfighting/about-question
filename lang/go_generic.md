### Go与泛型

作为java出身的搬砖工，泛型的地位以及应用都是相当高的。

那么泛型是什么呢？使用泛型带来的好处是什么呢？

泛型其实就是"参数化类型"。参数我们最熟悉的就是定义方法时的行参，然后调用此方法时传递的实参。再通俗点解释参数化类型就是
将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式，然后在使用/调用的时候传入具体的类型。

泛型的本质是为了参数化类型，即在不创建新的类型的情况下，通过泛型指定不同类型来控制形参具体限制的类型，也就是在泛型的使用过程中，
操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被成为泛型类、泛型接口、泛型方法...

---

说到这里，好像引入泛型也不错。

Go是一门语法元素少、设计简单的编程语言，简单的设计往往意味着较弱的表达能力，就好像c,c++一样，程序员往往也需要更多时间编写重复的逻辑。在GO诞生
至今关于语言层面支持泛型的讨论一直不绝入耳。好与坏可以看看下面的代码对比下：

```bigquery
下面的函数都是sort包提供的，而这些函数的功能也非常相似，底层实现也使用了近乎相同的逻辑，但是由于传入类型的不同却需要对外提供多个函数：

package sort

func Float64s(a []float64)

func Strings(a []string)

func Ints(a []int)

...

```

下面是摘录自java的代码

```bigquery

这段代码使用泛型数组作为参数实现了通用的数组排序逻辑，任意类型只要实现了Comparable接口，insertionSort函数就能排序由该对象
组成的数组。

public class ArraySortViaComparable {
    public <E extends Comparable> void insertionSort(E[] a) {
        for (int i = 1; i < a.length; i = i + 1) {
            Comparable itemToInsert = a[i];
            int j = i;
            while (j != 0 && greaterThan(a[j-1], itemToInsert)) {
                a[j] = a[j-1]
                j = j - 1
            };
            a[j] = itemToInsert;
        }
    }

    private static boolean greaterThan(E left, Object right) { return left.compareTo(right) == 1; }
}
```

对比完很直观的感受就是，泛型能减少重复的代码和逻辑，有更强的表达能力。但是泛型也存在困境。

#### 困境？

每种语言设计之初，都需要在编程效率、编译速度和运行速度三者进行权衡和选择，最明显的就是PHP和c,效率至少跟性能至上，每种语言都要选择牺牲三者之一而保留另外两个，这也是加入泛型所需要权衡的难题。

- 跟Go很像的C,c语言是系统级的编程语言，本身对于抽象能力就已经很有限了，更不用说支持泛型，需要手动实现不同类型的相同逻辑。不过好处也很明显，降低了编译器实现的复杂度，也提高了源代码的编译速度；

- c++ 除了命名跟c很接近外，取舍也是天差地别的，它在编译期间类型特化，实现了泛型，提供了非常强大的抽象能力，这很大程度提高了开发效率，不需要在重复手写同一逻辑的相似实现，但是编译器的实现就显得非常复杂，同时由于泛型的展开，
也导致最终编译的二进制文件巨大和编译时间漫长（业界说法是需要使用连接器来解决代码重复）；
  
- java利用类型擦除实现泛型，只是在编译期间用于检查类型正确，而类型擦除会删除泛型的相关信息，导致其在运行时不可用。同时，编译器会插入额外的类型转换指令，效果也很明显，与c/c++在编译阶段就已经实现不同，java的泛型会降低程度的执行效率；

这也是不同语言的决策不同，要么选择牺牲开发效率、牺牲编译速度，或者牺牲运行速度，因为泛型的引入一定会影响编译速度和运行速度，GO在考虑泛型的时候也十分谨慎，虽然社区提出了很多泛型的提案，目前还没一个明确的选择，看后续GO 2 版本会不会有所抉择吧。
同时，GO语言其实本身还有需要完成的运行机制，比如调度器、一直在优化的垃圾回收器等。

### 结语

其实关注GO的社区就知道，GO从来没有立场分明地反对加入泛型。在19年7月的时候，Go团队就发布了Go 2 的泛型设计草稿，主要是建议增加参数多态来拓展GO语言，而有了
参数多态，函数能够接收的参数就不再限于子类型关系，还可以显式的结构约束，类似下面的代码：

```bigquery
func Stringify(type T stringer)(s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
```

当然这还只是草稿。

